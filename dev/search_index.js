var documenterSearchIndex = {"docs":
[{"location":"#My-Replication-of-Asset-Prices-in-a-Huggett-economy","page":"My Replication of Asset Prices in a Huggett economy","title":"My Replication of Asset Prices in a Huggett economy","text":"","category":"section"},{"location":"#This-is-joint-work-with-Matteo-Cremonini","page":"My Replication of Asset Prices in a Huggett economy","title":"This is joint work with Matteo Cremonini","text":"","category":"section"},{"location":"","page":"My Replication of Asset Prices in a Huggett economy","title":"My Replication of Asset Prices in a Huggett economy","text":"This replication study was part of my evaluation for the course Numerical Methods at Bocconi in Winter 2021/2022","category":"page"},{"location":"","page":"My Replication of Asset Prices in a Huggett economy","title":"My Replication of Asset Prices in a Huggett economy","text":"In this replication study, our main contribution has been to code a procedure which plots and computes the excess demand function of a Huggett economy, for any interest rate level and for any borrowing constraint level.","category":"page"},{"location":"","page":"My Replication of Asset Prices in a Huggett economy","title":"My Replication of Asset Prices in a Huggett economy","text":"The package exports all values needed to replicate the paper into the user's Environment, while the file Graphs.jl plots the two figures of the paper. Since no replication material from the authors was available we coded the procedure by ourself, so any suggestion for improvement or speeding-up the procedure is very welcomed!","category":"page"},{"location":"","page":"My Replication of Asset Prices in a Huggett economy","title":"My Replication of Asset Prices in a Huggett economy","text":"AssetGrid\ncrra\ninitguess\nnext_guess\nhousehold\nlambda\neD","category":"page"},{"location":"#Huggett.AssetGrid","page":"My Replication of Asset Prices in a Huggett economy","title":"Huggett.AssetGrid","text":"function AssetGrid(borrow)\n\nCreates a grid of equally spaced points ranging from the minimum level of assets, i.e. the borrowing constraint level borrow (which has to be specified by the user).  The maximum number of assets a_max = 24 and the number of assets na=500 have been specified for the sake of the replication exercise.\n\nInputs:\n\nborrow::Float64 : Borrowing constraint level for the Huggett economy. Notice that borrow<=0 must hold since in the Huggett economy considered the assets are not in positive net supply. \n\nOutputs:\n\nColumn vector of dimension na of type Vector{Float64}\n\n\n\n\n\n","category":"function"},{"location":"#Huggett.crra","page":"My Replication of Asset Prices in a Huggett economy","title":"Huggett.crra","text":"function crra(c,σ)\n\nComputes the utility associated to a level of consumption c, when the utility function is a CRRA utility with constant relative risk aversion parameter equal to σ. Remember that a CRRA utility function takes the form c^{1-σ}/1-σ\n\nInputs:\n\nc::Float64: the level of consumption for which we want to compute the associated utility. Notice that c>=0 must hold.\nσ::Float64: relative risk aversion parameter of the CRRA utility function. \n\nOutputs:\n\nA scalar of type Float64 indicating the utility level.\n\n\n\n\n\n","category":"function"},{"location":"#Huggett.initguess","page":"My Replication of Asset Prices in a Huggett economy","title":"Huggett.initguess","text":"function initguess(r, borrow)\n\nComputes an initial guess for the Value Function to start the Value Function Iteration (VFI) procedure used to solve the household problem of the Huggett economy. It is not necessary to run this function in order to solve the household problem, since the Contraction Mapping Theorem guarantees the convergence of the Value Function Iteration procedure, starting from any Value Function Guess. However, running this function makes the code faster. \n\nInputs:\n\nr::interest: the interest rate used to solve the household’s problem.\nborrow::Float64 : the borrowing constraint level to be specified by the user.\n\nOutputs:\n\nns x na vector of type Vector{Float64} to be used as a starting guess of the VFI procedure, where na is the number of assets and ns is the number of states for the income process.\n\n\n\n\n\n","category":"function"},{"location":"#Huggett.next_guess","page":"My Replication of Asset Prices in a Huggett economy","title":"Huggett.next_guess","text":"function next_guess(V,pol, borrow)\n\nImplements the Howard’s improvement algorithm, which is used to update the value function after each step of the value function iteration procedure.  The basic idea of Howard’s Improvement Step is that instead of finding a maximizer for each iteration of the VFI procedure, the same maximizer should be used repeatedly for a specified  number of iterations (e.g. 70). The resulting Value Function will be the starting point of the following step of the VFI procedure. \n\nInputs:\n\nV::Vector{Float64} : Vector of dimension ns x na which represents the Value function obtained at the end of any step of the VFI procedure.\npol::Vector{Int64} : Policy Function is a column vector of length ns x na coming from a given iteration of the VFI procedure.\nborrow::Float64 : Borrowing constraint level to be specified by the user.\n\nOutputs:\n\nThe output of the function is a Value Function of dimension ns x na and type Vector{Float64} to be used in the next iteration of the VFI procedure\n\n\n\n\n\n","category":"function"},{"location":"#Huggett.household","page":"My Replication of Asset Prices in a Huggett economy","title":"Huggett.household","text":"function household(v,r, borrow)\n\nImplements the VFI iteration procedure in order to solve the household problem of the Huggett economy for a given interest rate r and a given borrowing constraint. The Value function obtained from   the function initguess is used as an input, serving as the initial guess in the VFI procedure. Furthermore, the function calls next_guess at the end of each step of the VFI procedure: in this way Howard’s improvement algorithm is used to obtain the next guess of the VFI procedure. \n\nInputs:\n\nv::Vector{Float64} : Initial guess for Value Function.\nr::interest : Interest rate to be used for solving the household problem.\nborrow::Float64 : Borrowing constraint level to be specified by the user.\n\nOutput:\n\nA tuple of the following type: Tuple{Vector{Float64}, Vector{Int64}, Float64}  where the first element of the Tuple is the Value Function, the second element in the Tuple is the Policy function, i.e. a vector of length ns x na .  The third element of the tuple, instead, is a scalar of Type Float64 indicating the size of the discrepancy between the value functions of two successive iterations. If this parameter is under the tolerance level set then the VFI procedure has converged correctly. \n\n\n\n\n\n","category":"function"},{"location":"#Huggett.lambda","page":"My Replication of Asset Prices in a Huggett economy","title":"Huggett.lambda","text":"function lambda(pol_new)\n\nTaking as input the policy function obtained solving Huggett’s household problem, this function computes the implied stationary distribution of assets in the economy. \n\nInputs:\n\npol_new::Vector{Int64} : the Policy Function is a column vector of length ns x na coming from a given iteration of the VFI procedure.\n\nOutputs:\n\nThe output is a vector of length na of type Vector{Float64}, displaying the probability of having any given level of assets. Stated differently, the output is the wealth (or asset) distribution across the agents in the economy. \n\n\n\n\n\n","category":"function"},{"location":"#Huggett.eD","page":"My Replication of Asset Prices in a Huggett economy","title":"Huggett.eD","text":"function eD(pol_new,lambda, borrow)\n\nThis function retrieves the excess demand in the Hugget's economy given the Policy Function, the asset’s stationary distribution and the level of borrowing constraints. Stated in an equivalent way, given any level of interest rate r this function takes the policy function coming from the household function, and the induced stationary distribution of assets coming from the lambda function in order to compute the excess demand of the considered Huggett economy (with level of borrowing constraint borrow).\n\nInputs:\n\npol_new::Vector{Int64} : the Policy Function is a column vector of length ns x na coming from the solution of the household problem when the given interest rate is r.\nlambda::Vector{Int64} : the stationary distribution of assets in the Huggett economy. \nborrow::Float64 : the borrowing constraint level imposed on the Huggett economy.\n\nOutputs:\n\nA scalar of type Float64 indicating the excess demand in the considered Huggett economy. Notice that if excess demand = 0 then the interest rate which delivers pol_new as a policy function is the general equilibrium interest rate!\n\n\n\n\n\n","category":"function"}]
}
